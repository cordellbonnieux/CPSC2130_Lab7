<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Cordell Bonnieux's Lab 7</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas")
        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render()
                }
            })
        }

        var engine = null
        var scene = null
        var sceneToRender = null
        var createDefaultEngine = function() { 
            return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); 
        }

        // You have to create a function called createScene. This function must return a BABYLON.Scene object
        // You can reference the following variables: engine, canvas
        // You must at least define a camera

        var createScene = function() {
            var scene = new BABYLON.Scene(engine);

            // physics
            scene.enablePhysics()
            //scene.gravity = new BABYLON.Vector3(0, -10, 0)

            // camera - edit
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 12, BABYLON.Vector3.Zero(), scene)

            // light from top
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene)

            // add gravity
            scene.gravity = new BABYLON.Vector3(0, -9.81, 0)

            // player
            const player = makePlayer()

            // ground 
            const ground = makeGround()

            // walls
            const walls = makeWalls()

            // boxes
            const box = makeBox(1)
            /*

            something's wrong here

            let boxes = []
            let num = 25
            for (let i = 0; i < num; i++) {
                boxes.push(makeBox(i))
            }
            */

            // This targets the camera to player
            camera.setTarget(player)

            // This attaches the camera to the canvas
            camera.attachControl(canvas, true)

            // ui text
            const ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI')
            let text = new BABYLON.GUI.TextBlock()
            text.text = 'hello'
            text.color = 'white'
            text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP
            text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT
            ui.addControl(text)


            // input listeners
            const controls = addControls(text)

            // preload
            scene.registerBeforeRender(() => {
                if (!scene.isReady()) {
                    return
                }

                if (player.intersectsMesh(ground, true)) {
                    // player is on the ground
                    player.grounded = true
                }
                
                isPlayerInside(player)

                if (controls.space && player.grounded) {
                    // jump
                    player.grounded = false
                    const up = new BABYLON.Vector3(player.position._x, player.position._y + 1, player.position._z)
                    player.impostor.applyImpulse(new BABYLON.Vector3(0, 100, 0), up)
                }
                if (controls.a) { 
                    // move left
                    //const left = new BABYLON.Vector3(player.position._x + 1, player.position._y, player.position._z)
                    //player.impostor.applyImpulse(new BABYLON.Vector3(-1, 0, 0), left)
                    player.moveWithCollisions(new BABYLON.Vector3(-1, 0, 0))
                }
                if (controls.d) {
                    // move right
                    //const right = new BABYLON.Vector3(player.position._x - 1, player.position._y, player.position._z)
                    //player.impostor.applyImpulse(new BABYLON.Vector3(1, 0, 0), right)
                    player.moveWithCollisions(new BABYLON.Vector3(1, 0, 0))
                }
                if (controls.w) {
                    // move forward
                    player.moveWithCollisions(new BABYLON.Vector3(0, 0, 1))
                }
                if (controls.s) {
                    // move backward
                    player.moveWithCollisions(new BABYLON.Vector3(0, 0, -1))
                }
            })

            return scene;
        };

        window.initFunction = async function() {           
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine()
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead")
                    return createDefaultEngine()
                }
            }
            window.engine = await asyncEngineCreation()
            if (!engine) {
                throw 'engine should not be null.'
            }
            startRenderLoop(engine, canvas)
            window.scene = createScene()
        }
            
        initFunction().then(() => {
            sceneToRender = scene                    
        })

        // Resize
        window.addEventListener("resize", function () {
            engine.resize()
        })

        // inputs 
        function addControls(text) {
            let controls = {
                w: false,
                a: false,
                s: false,
                d: false
            }

            document.addEventListener('keydown', (e) => {
                let key = null
                if (e.keyCode == 87) {
                    controls.w = true
                    key = 'w'
                }
                if (e.keyCode == 65) {
                    controls.a = true
                    key = 'a'
                }
                if (e.keyCode == 83) {
                    controls.s = true
                    key = 's'
                }
                if (e.keyCode == 68) {
                    controls.d = true
                    key = 'd'
                }
                if (e.keyCode == 32) {
                    controls.space = true
                    key = 'space'
                }
                key = key == null ? 'unassigned key' : key
                text.text = `key pressed: ${key}`
            })

            document.addEventListener('keyup', (e) => {
                text.text = `key pressed: `
                if (e.keyCode == 87) {
                    controls.w = false
                }
                if (e.keyCode == 65) {
                    controls.a = false
                }
                if (e.keyCode == 83) {
                    controls.s = false
                }
                if (e.keyCode == 68) {
                    controls.d = false
                }
                if (e.keyCode == 32) {
                    controls.space = false
                }           
            })
            return controls
        }

        // make the player
        function makePlayer() {
            let player = BABYLON.MeshBuilder.CreateSphere("player", {}, scene);

            // material
            let playerMaterial = new BABYLON.StandardMaterial(scene)
            playerMaterial.alpha = 0.8
            playerMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.2, 0.7)
            player.material = playerMaterial

            player.checkCollisions = true
            player.grounded = true

            // gravity
            player.impostor = new BABYLON.PhysicsImpostor(player, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 10, friction: 0.0, restitution: 0.3 }, scene);
            return player
        }

        // make the ground so player does not fall through the floor!
        function makeGround() {
            // create ground and set y pos
            const ground = BABYLON.MeshBuilder.CreateBox("Ground", {width: 100, height: 1, depth: 100}, scene)
            ground.position.y = -5.0

            // no gravity for ground
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.0, restitution: 0.7 }, scene)

            // ground material and shadows
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene)
            groundMat.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
            groundMat.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
            groundMat.backFaceCulling = false
            ground.material = groundMat
            ground.receiveShadows = true

            return ground
        }  

        function makeBox(i) {
            let box = BABYLON.MeshBuilder.CreateBox(`box${i}`, {width: 2, height: 2, depth: 2}, scene)
            box.position._x = (box.position._x * i) + 5
            box.position._z = (box.position._z * i) + 5

            // material
            let material = new BABYLON.StandardMaterial(scene)
            material.alpha = 1
            material.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
            material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
            box.material = material

            // gravity
            box.impostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.0, restitution: 0 }, scene)
            return box
        }

        function makeWalls() {
            let walls = []
            for (let i = 0; i < 4; i++) {
                // constructor
                let wall = BABYLON.MeshBuilder.CreatePlane(`wall${i}`, {width: 100, height: 15, depth: 10, subdivsions: 1})
                // collisions
                wall.checkCollisions = true
                // material
                wall.material = new BABYLON.StandardMaterial(`wall${i}`)
                wall.material.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
                wall.material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random())
                // positioning
                wall.position.y = -2
                switch (i) {
                    case 0: wall.position.z = 50
                        break
                    case 1: wall.position.x = 50
                        wall.addRotation(0, Math.PI/2, 0)
                        break
                    case 2: wall.position.z = -50
                        break 
                    case 3: wall.position.x = -50
                        wall.addRotation(0, Math.PI/2, 0)
                }
                // return the array containing the walls
                walls.push(wall)
            }
           return walls
        }

        function isPlayerInside(p) {
            if (p.position.x > 50 || p.position.x < -50 || p.position.z > 50 || p.position.z < -50) {
                p.position.x = 0
                p.position.y = 0
                p.position.z = 0
            }
            /*
            if (p.imposter.checkCollisions) {
                console.log('collision detected')
            }
            */
        }
    </script>
</body>
</html>
